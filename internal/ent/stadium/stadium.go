// Code generated by ent, DO NOT EDIT.

package stadium

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the stadium type in the database.
	Label = "stadium"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldTeam holds the string denoting the team field in the database.
	FieldTeam = "team"
	// FieldFdcouk holds the string denoting the fdcouk field in the database.
	FieldFdcouk = "fdcouk"
	// FieldCity holds the string denoting the city field in the database.
	FieldCity = "city"
	// FieldStadium holds the string denoting the stadium field in the database.
	FieldStadium = "stadium"
	// FieldCapacity holds the string denoting the capacity field in the database.
	FieldCapacity = "capacity"
	// FieldLatitude holds the string denoting the latitude field in the database.
	FieldLatitude = "latitude"
	// FieldLongitude holds the string denoting the longitude field in the database.
	FieldLongitude = "longitude"
	// FieldCountry holds the string denoting the country field in the database.
	FieldCountry = "country"
	// EdgeWeather holds the string denoting the weather edge name in mutations.
	EdgeWeather = "weather"
	// Table holds the table name of the stadium in the database.
	Table = "stadia"
	// WeatherTable is the table that holds the weather relation/edge.
	WeatherTable = "weathers"
	// WeatherInverseTable is the table name for the Weather entity.
	// It exists in this package in order to avoid circular dependency with the "weather" package.
	WeatherInverseTable = "weathers"
	// WeatherColumn is the table column denoting the weather relation/edge.
	WeatherColumn = "stadium_weather"
)

// Columns holds all SQL columns for stadium fields.
var Columns = []string{
	FieldID,
	FieldTeam,
	FieldFdcouk,
	FieldCity,
	FieldStadium,
	FieldCapacity,
	FieldLatitude,
	FieldLongitude,
	FieldCountry,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "us-soccer-go-test/internal/ent/runtime"
var (
	Hooks  [1]ent.Hook
	Policy ent.Policy
	// TeamValidator is a validator for the "team" field. It is called by the builders before save.
	TeamValidator func(string) error
	// FdcoukValidator is a validator for the "fdcouk" field. It is called by the builders before save.
	FdcoukValidator func(string) error
	// CityValidator is a validator for the "city" field. It is called by the builders before save.
	CityValidator func(string) error
	// StadiumValidator is a validator for the "stadium" field. It is called by the builders before save.
	StadiumValidator func(string) error
	// CountryValidator is a validator for the "country" field. It is called by the builders before save.
	CountryValidator func(string) error
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// OrderOption defines the ordering options for the Stadium queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByTeam orders the results by the team field.
func ByTeam(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTeam, opts...).ToFunc()
}

// ByFdcouk orders the results by the fdcouk field.
func ByFdcouk(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFdcouk, opts...).ToFunc()
}

// ByCity orders the results by the city field.
func ByCity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCity, opts...).ToFunc()
}

// ByStadium orders the results by the stadium field.
func ByStadium(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStadium, opts...).ToFunc()
}

// ByCapacity orders the results by the capacity field.
func ByCapacity(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCapacity, opts...).ToFunc()
}

// ByLatitude orders the results by the latitude field.
func ByLatitude(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLatitude, opts...).ToFunc()
}

// ByLongitude orders the results by the longitude field.
func ByLongitude(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLongitude, opts...).ToFunc()
}

// ByCountry orders the results by the country field.
func ByCountry(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCountry, opts...).ToFunc()
}

// ByWeatherField orders the results by weather field.
func ByWeatherField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newWeatherStep(), sql.OrderByField(field, opts...))
	}
}
func newWeatherStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(WeatherInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, WeatherTable, WeatherColumn),
	)
}
